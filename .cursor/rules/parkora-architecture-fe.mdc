---
description: Core frontend architecture  for Parkora Partners Web 
globs: src/**
---

# Parkora Frontend Architecture Rules

## Core Principles

1. **Single Responsibility**: Each component, hook, store has one clear purpose
2. **Composition Over Complexity**: Break down complex logic into smaller, reusable pieces
3. **Type Safety First**: TypeScript interfaces for all props, state, and return types — no `any`
4. **Predictable State**: Zustand for global state, useState for UI-only concerns
5. **Separation of Concerns**: UI (components) | Logic (hooks) | Data (services/stores)
6. **Colocation**: Keep related code together — styles, tests, types near their component
7. **Immutability**: Never mutate state directly; always return new references

## Root-Level Structure

```
src/
├── assets/          # Static assets (images, fonts, icons)
├── components/      # Reusable UI components
├── pages/           # Page-level components
├── routes/          # Route configuration and guards
├── services/        # API calls and external service integrations
├── stores/          # Zustand state stores
├── types/           # All TypeScript type definitions
├── utils/           # Utility/helper functions
├── App.tsx          # Root application component
├── App.css          # App-level scoped styles
├── main.tsx         # Application entry point
└── index.css        # Base reset styles only
```

| Folder | Purpose |
|--------|---------|
| `assets/` | Static files: images, SVGs, fonts |
| `components/` | Reusable UI components organized by feature or atomic design |
| `pages/` | Page-level components (one folder per page with its styles) |
| `routes/` | Router config, route guards, path constants |
| `services/` | API calls, HTTP client config, external service integrations |
| `stores/` | Zustand stores for global state management (state only, no API calls) |
| `types/` | All TypeScript interfaces, types, and enums |
| `utils/` | Reusable utility/helper functions |

### Recommended Additions

```
src/
├── assets/
├── components/
├── constants/       # App-wide constants
├── hooks/           # Custom React hooks
├── pages/           # Page/route components
├── services/        # API calls and external services
├── stores/          # Zustand stores
├── types/
├── utils/           # Utility functions
├── App.tsx
├── App.css
├── main.tsx
└── index.css
```

## Naming Conventions

| Element | Convention | Example |
|---------|------------|---------|
| Components | PascalCase | `UserProfile`, `LoginButton` |
| Interfaces | PascalCase + Suffix | `UserProps`, `AuthState`, `ApiResponse` |
| Constants | SCREAMING_SNAKE_CASE | `MAX_RETRY_COUNT`, `API_BASE_URL` |
| Stores | camelCase with `use` prefix + `Store` suffix | `useAuthStore`, `useUserStore` |
| Files | PascalCase | `UserProfile.tsx`, `AuthService.ts` |

### Components

```tsx
const UserProfile = () => { ... }
const LoginButton = () => { ... }
```

### Interfaces

```tsx
interface UserProps { ... }
interface AuthState { ... }
interface LoginFormData { ... }
```

### Constants

```tsx
const MAX_RETRY_COUNT = 3;
const API_BASE_URL = 'https://api.example.com';
const DEFAULT_PAGE_SIZE = 10;
```

### Stores

```tsx
const useAuthStore = create<AuthState>(() => ({ ... }));
const useUserStore = create<UserState>(() => ({ ... }));
const useCartStore = create<CartState>(() => ({ ... }));
```

### Files

```
UserProfile.tsx
AuthService.ts
LoginButton.tsx
ApiUtils.ts
```

## Utils Rules

- **Reuse before creating new utils**  
  - Before adding a new utility class or method under `util/`, check whether an existing util already provides the same behavior.  
  - Prefer extending or improving existing shared utilities instead of introducing near-duplicate helpers.

- **No utils for a single consumer**  
  - Do **not** create a utility class or method if it is only used by a single controller or service; keep that logic local to its owning class.  
  - Promote code into `util/` only when it has multiple, clear consumers or is expected to be reused across modules.