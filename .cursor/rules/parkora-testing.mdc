---
description: Testing rules for Parkora Partners Web - Jest testing conventions
globs: src/__tests__/**/*.test.*
---

# Parkora Testing Rules

## What to Test

Only create tests for **services and business logic**. Do NOT test UI components.

| Test | Don't Test |
|------|------------|
| Services (`services/`) | Components (`components/`) |
| Utility functions (`utils/`) | Pages (`pages/`) |
| Store actions (`stores/`) | Styling/CSS |
| Custom hooks logic (`hooks/`) | Third-party libraries |

## Arrange-Act-Assert (AAA) Pattern

All tests MUST follow the AAA pattern with clear section comments.

### Structure

```tsx
describe('ServiceName', () => {
  describe('methodName', () => {
    it('should do something when condition', () => {
      // Arrange
      const input = 'test';
      const expected = 'result';

      // Act
      const result = serviceName.methodName(input);

      // Assert
      expect(result).toBe(expected);
    });
  });
});
```

### Correct

```tsx
describe('AuthService', () => {
  describe('validateEmail', () => {
    it('should return true for valid email', () => {
      // Arrange
      const email = 'user@example.com';

      // Act
      const result = AuthService.validateEmail(email);

      // Assert
      expect(result).toBe(true);
    });

    it('should return false for invalid email', () => {
      // Arrange
      const email = 'invalid-email';

      // Act
      const result = AuthService.validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });
  });
});
```

### Forbidden

```tsx
it('validates email', () => {
  expect(AuthService.validateEmail('user@example.com')).toBe(true);
  expect(AuthService.validateEmail('invalid')).toBe(false);
});
```

## Reusable Test Data

When Arrange data is shared across multiple test cases, extract it to avoid duplication.

### Use `beforeEach` for Shared Setup

```tsx
describe('UserService', () => {
  // Arrange (shared)
  let mockUser: User;

  beforeEach(() => {
    mockUser = {
      id: '1',
      name: 'John Doe',
      email: 'john@example.com',
    };
  });

  it('should return user full name', () => {
    // Act
    const result = UserService.getFullName(mockUser);

    // Assert
    expect(result).toBe('John Doe');
  });

  it('should validate user email', () => {
    // Act
    const result = UserService.hasValidEmail(mockUser);

    // Assert
    expect(result).toBe(true);
  });
});
```

### Use Test Fixtures for Complex Data

```tsx
// __tests__/fixtures/userFixtures.ts
export const mockUsers = {
  validUser: {
    id: '1',
    name: 'John Doe',
    email: 'john@example.com',
  },
  invalidUser: {
    id: '2',
    name: '',
    email: 'invalid-email',
  },
} as const;

// __tests__/services/UserService.test.ts
import { mockUsers } from '../fixtures/userFixtures';

describe('UserService', () => {
  it('should validate user with valid data', () => {
    // Arrange
    const user = mockUsers.validUser;

    // Act
    const result = UserService.validate(user);

    // Assert
    expect(result).toBe(true);
  });
});
```

### Rules for Reusable Data

1. **Use `beforeEach`** - For data that resets between tests
2. **Use fixtures** - For static test data shared across files
3. **Keep test-specific data inline** - If only used in one test, keep it in Arrange
4. **No global mutable state** - Always reset in `beforeEach`

## Test File Naming

| Source File | Test File |
|-------------|-----------|
| `AuthService.ts` | `AuthService.test.ts` |
| `formatDate.ts` | `formatDate.test.ts` |
| `useAuthStore.ts` | `useAuthStore.test.ts` |

## Test File Location

Place tests in `__tests__/` folder mirroring the source structure:

```
src/
├── services/
│   └── AuthService.ts
├── utils/
│   └── formatDate.ts
└── __tests__/
    ├── services/
    │   └── AuthService.test.ts
    └── utils/
        └── formatDate.test.ts
```

## Rules Summary

1. **Services & logic only** - No component tests
2. **AAA pattern** - Always use Arrange-Act-Assert with comments
3. **Reusable Arrange data** - Use `beforeEach` or fixtures for shared test data
4. **One assertion focus** - Each test should verify one behavior
5. **Descriptive names** - `should [action] when [condition]`
6. **Group by method** - Use nested `describe` blocks
