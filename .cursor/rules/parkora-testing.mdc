---
description: Testing rules for Parkora Partners Web - Jest testing conventions
globs: src/__tests__/**/*.test.*
---

# Parkora Testing Rules

## What to Test

Only create tests for **services and business logic**. Do NOT test UI components.

| Test | Don't Test |
|------|------------|
| Services (`services/`) | Components (`components/`) |
| Utility functions (`utils/`) | Pages (`pages/`) |
| Store actions (`stores/`) | Styling/CSS |
| Custom hooks logic (`hooks/`) | Third-party libraries |

## Arrange-Act-Assert (AAA) Pattern

All tests MUST follow the AAA pattern with clear section comments.

### Structure

```tsx
describe('ServiceName', () => {
  describe('methodName', () => {
    it('should do something when condition', () => {
      // Arrange
      const input = 'test';
      const expected = 'result';

      // Act
      const result = serviceName.methodName(input);

      // Assert
      expect(result).toBe(expected);
    });
  });
});
```

### Correct

```tsx
describe('AuthService', () => {
  describe('validateEmail', () => {
    it('should return true for valid email', () => {
      // Arrange
      const email = 'user@example.com';

      // Act
      const result = AuthService.validateEmail(email);

      // Assert
      expect(result).toBe(true);
    });

    it('should return false for invalid email', () => {
      // Arrange
      const email = 'invalid-email';

      // Act
      const result = AuthService.validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });
  });
});
```

### Forbidden

```tsx
it('validates email', () => {
  expect(AuthService.validateEmail('user@example.com')).toBe(true);
  expect(AuthService.validateEmail('invalid')).toBe(false);
});
```

## Reusable Test Data

When Arrange data is shared across multiple test cases, extract it to avoid duplication.

### Use `beforeEach` for Shared Setup

```tsx
describe('UserService', () => {
  // Arrange (shared)
  let mockUser: User;

  beforeEach(() => {
    mockUser = {
      id: '1',
      name: 'John Doe',
      email: 'john@example.com',
    };
  });

  it('should return user full name', () => {
    // Act
    const result = UserService.getFullName(mockUser);

    // Assert
    expect(result).toBe('John Doe');
  });

  it('should validate user email', () => {
    // Act
    const result = UserService.hasValidEmail(mockUser);

    // Assert
    expect(result).toBe(true);
  });
});
```

### Use Test Fixtures for Complex Data

```tsx
// __tests__/fixtures/userFixtures.ts
export const mockUsers = {
  validUser: {
    id: '1',
    name: 'John Doe',
    email: 'john@example.com',
  },
  invalidUser: {
    id: '2',
    name: '',
    email: 'invalid-email',
  },
} as const;

// __tests__/services/UserService.test.ts
import { mockUsers } from '../fixtures/userFixtures';

describe('UserService', () => {
  it('should validate user with valid data', () => {
    // Arrange
    const user = mockUsers.validUser;

    // Act
    const result = UserService.validate(user);

    // Assert
    expect(result).toBe(true);
  });
});
```

### Rules for Reusable Data

1. **Use `beforeEach`** - For data that resets between tests
2. **Use fixtures** - For static test data shared across files
3. **Keep test-specific data inline** - If only used in one test, keep it in Arrange
4. **No global mutable state** - Always reset in `beforeEach`

## Test File Naming

| Source File | Test File |
|-------------|-----------|
| `AuthService.ts` | `AuthService.test.ts` |
| `formatDate.ts` | `formatDate.test.ts` |
| `useAuthStore.ts` | `useAuthStore.test.ts` |

## Test File Location

Place tests in `__tests__/` folder mirroring the source structure:

```
src/
├── services/
│   └── AuthService.ts
├── utils/
│   └── formatDate.ts
└── __tests__/
    ├── services/
    │   └── AuthService.test.ts
    └── utils/
        └── formatDate.test.ts
```

## Positive & Negative Testing

Every service/function should have both positive and negative test cases.

| Type | Purpose | Example |
|------|---------|---------|
| **Positive** | Valid inputs produce expected results | Valid email returns true |
| **Negative** | Invalid inputs are handled gracefully | Empty string throws error |

### Structure with Positive & Negative

```tsx
describe('AuthService', () => {
  describe('validateEmail', () => {
    // Positive Tests
    describe('positive cases', () => {
      it('should return true for valid email format', () => {
        // Arrange
        const email = 'user@example.com';

        // Act
        const result = AuthService.validateEmail(email);

        // Assert
        expect(result).toBe(true);
      });

      it('should return true for email with subdomain', () => {
        // Arrange
        const email = 'user@mail.example.com';

        // Act
        const result = AuthService.validateEmail(email);

        // Assert
        expect(result).toBe(true);
      });
    });

    // Negative Tests
    describe('negative cases', () => {
      it('should return false for empty string', () => {
        // Arrange
        const email = '';

        // Act
        const result = AuthService.validateEmail(email);

        // Assert
        expect(result).toBe(false);
      });

      it('should return false for email without @ symbol', () => {
        // Arrange
        const email = 'userexample.com';

        // Act
        const result = AuthService.validateEmail(email);

        // Assert
        expect(result).toBe(false);
      });

      it('should throw error for null input', () => {
        // Arrange
        const email = null;

        // Act & Assert
        expect(() => AuthService.validateEmail(email)).toThrow('Email is required');
      });
    });
  });
});
```

### Positive Test Cases

Test expected behavior with valid inputs:

- Valid data formats
- Typical use cases
- Boundary values (min/max valid)
- Different valid variations

### Negative Test Cases

Test error handling with invalid inputs:

- Empty values (`''`, `[]`, `{}`)
- Null and undefined
- Wrong data types
- Out of range values
- Malformed data
- Missing required fields

### Rules for Positive & Negative

1. **Both required** - Every function needs positive AND negative tests
2. **Group separately** - Use `describe('positive cases')` and `describe('negative cases')`
3. **Test error messages** - Verify error messages, not just that errors are thrown
4. **Cover edge cases** - Empty, null, undefined, boundary values

## Rules Summary

1. **Services & logic only** - No component tests
2. **AAA pattern** - Always use Arrange-Act-Assert with comments
3. **Reusable Arrange data** - Use `beforeEach` or fixtures for shared test data
4. **Positive & Negative tests** - Both required for every function
5. **One assertion focus** - Each test should verify one behavior
6. **Descriptive names** - `should [action] when [condition]`
7. **Group by method** - Use nested `describe` blocks
