---
description: Component rules for Parkora Partners Web - React component conventions
globs: src/components/**/*.tsx
---

# Parkora Component Rules

## Core Principles

1. **Single responsibility** - One component, one purpose
2. **Reusable first** - Extract shared UI into reusable components
3. **Props over state** - Prefer controlled components
4. **Composition** - Build complex UI from simple components
5. **Types in `types/`** - Component prop types in `types/components/`

## Folder Structure

```
src/
├── types/
│   └── components/
│       ├── button.types.ts
│       ├── input.types.ts
│       └── modal.types.ts
│
├── components/
│   ├── common/                    # Reusable across entire app
│   │   ├── Button/
│   │   │   └── Button.tsx
│   │   ├── Input/
│   │   └── Modal/
│   │
│   ├── layout/                    # Layout components
│   │   ├── Header/
│   │   ├── Sidebar/
│   │   └── Footer/
│   │
│   └── features/                  # Feature-specific components
│       ├── auth/
│       │   ├── LoginForm/
│       │   └── RegisterForm/
│       └── dashboard/
│           ├── StatsCard/
│           └── RecentActivity/
```

## Component Categories

| Category | Location | Reusability |
|----------|----------|-------------|
| **Common** | `components/common/` | Used 3+ times across app |
| **Layout** | `components/layout/` | App structure components |
| **Feature** | `components/features/[domain]/` | Domain-specific, limited reuse |

## When to Extract a Reusable Component

| Signal | Action |
|--------|--------|
| Used in 3+ places | Move to `common/` |
| Generic UI element | Move to `common/` |
| Has no business logic | Move to `common/` |
| Used only in one feature | Keep in `features/[domain]/` |

## Standard Component Structure

### File Structure per Component

```
components/common/Button/
└── Button.tsx              # Component implementation
```

### Component Template

```tsx
// components/common/Button/Button.tsx
import { clsx } from 'clsx';
import type { ButtonProps } from '@/types/components/button.types';

export const Button = ({
  children,
  disabled = false,
  onClick,
  className,
  ...props
}: ButtonProps) => {
  return (
    <button
      className={clsx(
        'px-4 py-2 rounded font-medium transition-colors',
        'focus:outline-none focus:ring-2 focus:ring-offset-2',
        disabled && 'opacity-50 cursor-not-allowed',
        className
      )}
      disabled={disabled}
      onClick={onClick}
      {...props}
    >
      {children}
    </button>
  );
};
```

### Type Definition

```tsx
// types/components/button.types.ts
import type { ButtonHTMLAttributes, ReactNode } from 'react';

export interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  children: ReactNode;
  isLoading?: boolean;
}
```

## Component Naming Convention

| Element | Convention | Example |
|---------|------------|---------|
| Component | PascalCase | `UserProfile`, `LoginForm` |
| File | PascalCase | `UserProfile.tsx` |
| Folder | PascalCase | `UserProfile/` |
| Props interface | `[Component]Props` | `UserProfileProps` |

## Props Best Practices

### Correct

```tsx
// Destructure with defaults
export const Card = ({
  title,
  children,
  className,
}: CardProps) => {
  return (
    <div className={clsx('rounded-lg border p-4', className)}>
      <h3 className="text-lg font-semibold">{title}</h3>
      {children}
    </div>
  );
};
```

### Forbidden

```tsx
// Don't use props object directly
export const Card = (props: CardProps) => {
  return (
    <div className={props.className}>
      <h3>{props.title}</h3>
      {props.children}
    </div>
  );
};
```

## Composition Pattern

### Correct - Compound Components

```tsx
// components/common/Card/Card.tsx
export const Card = ({ children, className }: CardProps) => (
  <div className={clsx('rounded-lg border border-gray-200 bg-white', className)}>
    {children}
  </div>
);

Card.Header = ({ children }: CardHeaderProps) => (
  <div className="border-b border-gray-200 px-4 py-3 font-semibold">{children}</div>
);

Card.Body = ({ children }: CardBodyProps) => (
  <div className="p-4">{children}</div>
);

Card.Footer = ({ children }: CardFooterProps) => (
  <div className="border-t border-gray-200 px-4 py-3 flex justify-end gap-2">{children}</div>
);

// Usage
<Card>
  <Card.Header>Title</Card.Header>
  <Card.Body>Content</Card.Body>
  <Card.Footer>Actions</Card.Footer>
</Card>
```

### Correct - Children Composition

```tsx
// Simple composition with children
<Modal>
  <Modal.Title>Confirm Action</Modal.Title>
  <Modal.Content>Are you sure?</Modal.Content>
  <Modal.Actions>
    <Button variant="ghost">Cancel</Button>
    <Button variant="danger">Delete</Button>
  </Modal.Actions>
</Modal>
```

## Event Handler Naming

| Event | Handler Name |
|-------|--------------|
| Click | `onClick`, `onButtonClick` |
| Change | `onChange`, `onInputChange` |
| Submit | `onSubmit`, `onFormSubmit` |
| Custom | `on[Action]` pattern |

```tsx
interface FormProps {
  onSubmit: (data: FormData) => void;
  onCancel: () => void;
  onChange: (field: string, value: string) => void;
}
```

## Reusable vs Feature Components

### Reusable (common/)

```tsx
// Generic, no business logic
export const Button = ({ children, onClick, className }: ButtonProps) => (
  <button
    className={clsx(
      'px-4 py-2 rounded font-medium transition-colors',
      className
    )}
    onClick={onClick}
  >
    {children}
  </button>
);
```

### Feature-specific (features/)

```tsx
// Contains business logic, domain-specific
export const LoginForm = () => {
  const { login } = useAuthStore();
  
  const handleSubmit = async (data: LoginData) => {
    await AuthService.login(data);
    login(data);
  };

  return (
    <form onSubmit={handleSubmit}>
      <Input name="email" label="Email" />
      <Input name="password" type="password" label="Password" />
      <Button type="submit">Login</Button>
    </form>
  );
};
```

## Rules Summary

1. **Folder per component** - Each component has its own folder
2. **Types in `types/components/`** - All prop types centralized
3. **Extract at 3+ uses** - Move to `common/` when used 3+ times
4. **Destructure props** - Always destructure with defaults
5. **Composition over props** - Use children and compound patterns
6. **No business logic in common** - Keep reusable components pure
7. **PascalCase everywhere** - Files, folders, components
